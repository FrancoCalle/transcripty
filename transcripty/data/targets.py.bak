"""
This file contains the calibration targets that we will use to find
the "optimal" parameters for the model
"""
import numpy as np

from collections import namedtuple


CPMParams = namedtuple("CPMParams", ["p", "sigma"])
HPMParams = namedtuple("HPMParams", ["gamma_min", "gamma_1", "gamma_2", "sigma"])


class CalibrationTargets(object):
    """
    This holds the calibration targets used for calibrating the model

    Parameters
    ----------
    credit_corr : float64
        The correlation between the credits earned in years 1 and 2
    y2_deciles_by_quartile : np.array((9, 5), float64)
        The 20/50/80 percent quantiles of total credits earned after
        two years for each gpa quartile

    Attributes
    ----------
    See parameters
    """
    def __init__(self, credit_corr, y2_deciles_by_quartile):
        self.credit_corr = credit_corr
        self.y2_deciles_by_quartile = y2_deciles_by_quartile

    def compare_results(self, gpa, credits, corrmult=25.0, normalize=False):
        """
        Compares the credit simulation results with the calibration
        targets

        Parameters
        ----------
        gpa : np.array((N,), float64)
            A simulation of gpa of N individuals
        credits : np.array((N, T_c), float64)
            A simulation of credits earned by N individuals over T_c
            periods
        corrmult : float64, optional(25.0)
            A multiplier used to scale the importance of the correlation
            between years 1 and 2
        normalize : bool, optional(false)
            If normalize is true then computes the percent difference
            in targets rather than absolute differences

        Returns
        -------
        diff : float64
            The 'score' of a particular simulation. The higher the
            score, the less we believe the parameters that generated
            the score
        """
        # Pull out the y1/y2 credits and compute total credits after
        # 2 years
        y1_credits = credits[:, 0]
        y2_credits = credits[:, 1]
        total_credits = y1_credits + y2_credits

        # Credit correlations
        credit_corr_sim = np.corrcoef(y1_credits, y2_credits)[0, 1]

        # Determine quartile cutoffs
        quartiles = np.quantile(gpa, [0.25, 0.5, 0.75])
        q1 = gpa < quartiles[0]
        q2 = (gpa >= quartiles[0]) & (gpa < quartiles[1])
        q3 = (gpa >= quartiles[1]) & (gpa < quartiles[2])
        q4 = (gpa >= quartiles[2])
        total = (gpa > -np.inf)

        diff = 0.0
        if normalize:
            diff += ((100*credit_corr_sim/self.credit_corr) - 100.0)**2
            for (i, q) in enumerate([q1, q2, q3, q4, total]):
                tc_q = np.quantile(total_credits[q], [0.20, 0.50, 0.80])
                diff += np.sum(((100*tc_q/self.y2_deciles_by_quartile[i, :]) - 100.0)**2)
        else:
            diff += (corrmult*(credit_corr_sim - self.credit_corr))**2
            for (i, q) in enumerate([q1, q2, q3, q4, total]):
                tc_q = np.quantile(total_credits[q], [0.20, 0.50, 0.80])
                diff += np.sum((tc_q - self.y2_deciles_by_quartile)**2)

        return diff


HL_OPT_PARAMS = HPMParams(0.35, 0.6778, 1.0556, 0.0)

CREDIT_CORR_Y1Y2 = 0.4799253

Y2_DECILES_BY_QUARTILE = np.array([
    [21.0, 38.0, 57.0],
    [36.0, 50.0, 62.0],
    [37.0, 55.0, 64.0],
    [50.0, 61.0, 68.0],
    [41.0, 57.0, 66.0]
])

CT = CalibrationTargets(CREDIT_CORR_Y1Y2, Y2_DECILES_BY_QUARTILE)

